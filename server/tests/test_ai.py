import pytest
from fastapi.testclient import TestClient
from httpx import AsyncClient, ASGITransport
from unittest.mock import MagicMock, patch
from main import app
from ai import ai_router
from datetime import datetime
from firebase_admin import firestore

# Mount the router
app.include_router(ai_router, prefix="/ai")


@pytest.fixture
def mock_firebase_collection(mocker):
    """
    Fixture to mock Firebase database collections.
    Sets up mock behavior for document retrieval and update operations.
    """
    # Create mock chain
    doc_ref = MagicMock()
    collection_ref = MagicMock()
    uploads_ref = MagicMock()

    # Setup chain
    uploads_ref.document.return_value = doc_ref
    doc_ref.collection.return_value = collection_ref
    collection_ref.document.return_value = doc_ref

    # Setup get
    doc_ref.get.return_value.exists = True
    doc_ref.get.return_value.to_dict.return_value = {"user_id": "user123"}

    mock_collection = MagicMock()
    mock_collection.return_value = uploads_ref
    mocker.patch("ai.db.collection", mock_collection)
    return mock_collection


@pytest.fixture
def mock_server_timestamp(mocker):
    """
    Fixture to mock Firestore SERVER_TIMESTAMP for setting timestamps in Firestore documents.
    """
    return mocker.patch("ai.firestore.SERVER_TIMESTAMP", datetime.now())


### Tests for /ai/upload endpoint ###
@pytest.mark.asyncio
async def test_upload_successful(mock_firebase_collection, mock_server_timestamp):
    """
    Test case to verify successful upload of transcription data to Firebase.
    Mocks Firebase document retrieval and update operations. Checks if
    the correct response is returned upon successful upload.
    """
    mock_doc = MagicMock()
    mock_doc.exists = True
    mock_doc.to_dict.return_value = {"user_id": "user123"}
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.post(
            "/ai/upload",
            json={
                "text": "Sample transcription",
                "file_id": "file123",
                "user_id": "user123",
                "file_type": "video",
            },
        )

        # Assert that the response is as expected
        assert response.status_code == 200
        assert response.json()["message"] == "Text uploaded successfully"
        assert "text_id" in response.json()


@pytest.mark.asyncio
async def test_upload_invalid_file_type(mock_firebase_collection):
    """
    Test case to verify that an invalid file type in the upload request
    returns a 500 status with the correct error message.
    """
    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.post(
            "/ai/upload",
            json={
                "text": "Sample transcription",
                "file_id": "file123",
                "user_id": "user123",
                "file_type": "unsupported",
            },
        )

        # Assert that the response is as expected for an invalid file type
        assert response.status_code == 500
        assert (
            response.json()["detail"] == "Failed to store text: 400: Invalid file type"
        )


@pytest.mark.asyncio
async def test_upload_unauthorized_access(
    mock_firebase_collection, mock_server_timestamp
):
    """
    Test case to verify that a user who is not authorized to access the
    file receives a 500 status with the appropriate error message.
    """
    mock_doc = MagicMock()
    mock_doc.exists = True
    mock_doc.to_dict.return_value = {"user_id": "other_user"}
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.post(
            "/ai/upload",
            json={
                "text": "Sample transcription",
                "file_id": "file123",
                "user_id": "user123",
                "file_type": "video",
            },
        )

        # Assert that the response is as expected for unauthorized access
        assert response.status_code == 500
        assert (
            response.json()["detail"]
            == "Failed to store text: 403: Not authorized to access this file"
        )


### Tests for /ai/ask endpoint ###
@pytest.mark.asyncio
async def test_ask_question_successful(
    mocker, mock_firebase_collection, mock_server_timestamp
):
    """
    Test case to verify that asking a question returns a valid response
    with an answer generated by the mocked Anthropic client.
    """
    # Mock Firebase
    mock_doc = MagicMock()
    mock_doc.exists = True
    mock_doc.to_dict.return_value = {
        "text": "Sample transcription",
        "user_id": "user123",
        "conversation_history": [],
    }
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    # Mock Anthropic response
    mock_response = MagicMock()
    mock_response.content = [type("Content", (), {"text": "Mock answer"})]
    mock_anthropic = MagicMock()
    mock_anthropic.messages.create.return_value = mock_response
    mocker.patch("ai.anthropic", mock_anthropic)

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.post(
            "/ai/ask",
            json={
                "text_id": "text123",
                "question": "What is this about?",
                "user_id": "user123",
                "file_id": "file123",
                "file_type": "video",
            },
        )

        # Assert that the response is as expected
        assert response.status_code == 200
        assert response.json()["answer"] == "Mock answer"
        assert response.json()["text_id"] == "text123"


@pytest.mark.asyncio
async def test_ask_invalid_text_id(mock_firebase_collection):
    """
    Test case to verify that an invalid text_id returns a 500 status with
    the correct error message.
    """
    mock_doc = MagicMock()
    mock_doc.exists = False
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.post(
            "/ai/ask",
            json={
                "text_id": "invalid_text_id",
                "question": "What is this about?",
                "user_id": "user123",
                "file_id": "file123",
                "file_type": "video",
            },
        )

        # Assert that the response is as expected for an invalid text_id
        assert response.status_code == 500
        assert response.json()["detail"] == "Database error: 404: Text ID not found"


### Tests for /ai/conversation/{text_id} endpoint ###
@pytest.mark.asyncio
async def test_get_conversation_successful(mock_firebase_collection):
    """
    Test case to verify that retrieving conversation history works
    when the user is authorized and the text exists in the database.
    """
    mock_doc = MagicMock()
    mock_doc.exists = True
    mock_doc.to_dict.return_value = {
        "text": "Sample transcription",
        "user_id": "user123",
        "conversation_history": [
            {"question": "What is this about?", "answer": "Mock answer"}
        ],
        "created_at": "2024-11-01T00:00:00",
        "last_accessed": "2024-11-10T00:00:00",
    }
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.get(
            "/ai/conversation/text123",
            params={"user_id": "user123", "file_id": "file123", "file_type": "video"},
        )

        # Assert that the response contains the expected conversation history
        assert response.status_code == 200
        assert response.json()["text"] == "Sample transcription"
        assert len(response.json()["conversation"]) == 1


@pytest.mark.asyncio
async def test_get_conversation_unauthorized_access(mock_firebase_collection):
    """
    Test case to verify that unauthorized access to a conversation
    returns a 500 status with the appropriate error message.
    """
    mock_doc = MagicMock()
    mock_doc.exists = True
    mock_doc.to_dict.return_value = {"user_id": "other_user"}
    mock_firebase_collection.return_value.document.return_value.get.return_value = (
        mock_doc
    )

    async with AsyncClient(
        app=app, base_url="http://test", transport=ASGITransport(app=app)
    ) as ac:
        response = await ac.get(
            "/ai/conversation/text123",
            params={"user_id": "user123", "file_id": "file123", "file_type": "video"},
        )

        # Assert that the response is as expected for unauthorized access
        assert response.status_code == 500
        assert (
            response.json()["detail"]
            == "Failed to retrieve conversation: 403: Not authorized to access this text"
        )

